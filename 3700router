#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy
from difflib import SequenceMatcher


class Router:
    relations = {}
    sockets = {}
    ports = {}
    table = []
    messages = []

    def aggregate(self):
        for net in self.table:
            ip1 = net['network'].split(".")
            for check in self.table:
                ip2 = check['network'].split(".")
                if (net['peer'] == check['peer'] and net['localpref'] == check['localpref']
                    and net['ASPath'] == check['ASPath'] and net['selfOrigin'] == check['selfOrigin'] and net['origin'] == check['origin']):
                    if ip1[0] == ip2[0] and ip1[1] == ip2[1] and ip1[3] == "0" and ip2[3] == "0":
                        mask = check['netmask'].split(".")
                        if (int(ip2[2]) + (abs(int(mask[2]) - 255) + 1)) == int(ip1[2]):
                            self.table.remove(net)
                            if mask[3] == "0":
                                if mask[2] == "0":
                                    if mask[1] == "0":
                                        if mask[0] == "0":
                                            check['netmask'] = "0.0.0.0"
                                        else:
                                            check['netmask'] = str(int(mask[0]) - 1) + ".0.0.0"

                                    else:
                                        check['netmask'] = mask[0] + "." + str(int(mask[1])- 1) + ".0.0"
                                else:
                                    check['netmask'] = mask[0] + "." + mask[1] + "." + str(int(mask[2]) - 1) + ".0"
                            else:
                                check['netmask'] = mask[0] + "." + mask[1] + "." + mask[2] + "." + str(int(mask[3]) - 1)







                    # count = 0
                    # for i in (0, 1, 3):
                    #     print(ip1[i] + "!=" + ip2[i])
                    #     if ip1[i] == ip2[i]:
                    #         count += 1
                    # if count == 3 and (int(ip1[2]) - int(ip2[2]) == 1) and ip1[3] == 0:
                    #
                    #     print("-------------------------------------")
                    #     self.table.remove(check)
                    #     net['netmask'] = [int(z) for z in net['netmask'].split(".")]
                    #     for x in (3, 2, 1, 0):
                    #         if net['netmask'][x] != 0:
                    #             net['netmask'][x] -= 1
                    #             break
                    #     net['netmask'] = '.'.join(net['netmask'])
                    #     break

    def disaggregate(self):
        temp = []
        for i in self.messages:
            if i['type'] == "update":
                temp.append({'network': i['msg']['network'], 'netmask': i['msg']['netmask'], 'peer': i['src'],
                                   'localpref': i['msg']['localpref'], 'ASPath': i['msg']['ASPath'],
                                   'selfOrigin': i['msg']['selfOrigin'], 'origin': i['msg']['origin']})
                self.table = temp
            if i['type'] == "withdraw":
                for x in self.table:
                    for y in i['msg']:
                        if x['peer'] == i['src'] and x['network'] == y['network']:
                            self.table.remove(x)
        self.aggregate()















    def processMsg(self, msg, srcif):
        dic = json.loads(msg)
        if dic['type'] == "update":
            self.messages.append(dic)
            self.table.append({'network': dic['msg']['network'], 'netmask': dic['msg']['netmask'], 'peer': dic['src'],
                               'localpref': dic['msg']['localpref'], 'ASPath': dic['msg']['ASPath'],
                               'selfOrigin': dic['msg']['selfOrigin'], 'origin': dic['msg']['origin']})
            self.aggregate()
            temp = copy.deepcopy(dic['msg'])
            del temp['localpref']
            del temp['origin']
            del temp['selfOrigin']
            temp['ASPath'].insert(0, self.asn)
            if self.relations[dic['src']] == "cust":
                for neighbors in self.relations:
                    if dic['src'] != neighbors:
                        self.send(neighbors, json.dumps({'msg': {'netmask': temp['netmask'], 'ASPath': temp['ASPath'],
                                                                 'network': temp['network']},
                                                         'src': self.our_addr(neighbors),
                                                         'dst': neighbors, 'type': 'update'}))
            else:
                for customers in self.relations:
                    if dic['src'] != customers and self.relations[customers] == "cust":
                        print("worked")
                        print(self.relations[customers])
                        self.send(customers, json.dumps({'msg': {'netmask': temp['netmask'], 'ASPath': temp['ASPath'],
                                                                 'network': temp['network']},
                                                         'src': self.our_addr(customers),
                                                         'dst': customers, 'type': 'update'}))
        if dic['type'] == "withdraw":
            self.messages.append(dic)
            for x in self.table:
                for y in dic['msg']:
                    if x['peer'] == dic['src'] and x['network'] == y['network']:
                        self.table.remove(x)
            self.disaggregate()
            for neighbors in self.relations:
                if dic['src'] != neighbors:
                    self.send(neighbors, json.dumps({'msg': dic['msg'],
                                                     'src': self.our_addr(neighbors),
                                                     'dst': neighbors, 'type': 'withdraw'}))
        if dic['type'] == "dump":
            for neighbors in self.relations:
                self.send(neighbors, json.dumps({'src': self.our_addr(neighbors), 'dst': neighbors, 'type': 'table',
                                                 'msg': self.table}))

        if dic['type'] == "data":
            peer = []

            for net in self.table:
                if dic['dst'][0: dic['dst'].find('.')] in net['network']:
                    peer.append(net)

            if len(peer) == 1:
                if not ((self.relations[srcif] == "peer" or self.relations[srcif] == "prov") and (self.relations[
                    peer[0]['peer']] == "peer" or self.relations[peer[0]['peer']] == "prov")):
                    self.send(peer[0]['peer'],
                              json.dumps(
                                  {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                   'dst': dic['dst']}))
            else:
                temp = []
                maxes = []
                for p in peer:
                    maxes.append(SequenceMatcher(None, p['network'], dic['dst']).ratio())
                indices = [j for j, y in enumerate(maxes) if y == max(maxes)]
                for z in indices:
                    temp.append(peer[z])
                peer = temp

                if len(peer) == 1:
                    if not ((self.relations[srcif] == "peer" or self.relations[srcif] == "prov") and (
                            self.relations[
                                peer[0]['peer']] == "peer" or self.relations[peer[0]['peer']] == "prov")):
                        self.send(peer[0]['peer'],
                                  json.dumps(
                                      {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                       'dst': dic['dst']}))
                else:
                    temp = []
                    maxes = []
                    for p in peer:
                        maxes.append(p['localpref'])

                    indices = [j for j, y in enumerate(maxes) if y == max(maxes)]
                    for z in indices:
                        temp.append(peer[z])
                    peer = temp
                    if len(peer) == 1:
                        if not ((self.relations[srcif] == "peer" or self.relations[srcif] == "prov") and (
                                self.relations[
                                    peer[0]['peer']] == "peer" or self.relations[peer[0]['peer']] == "prov")):
                            self.send(peer[0]['peer'],
                                      json.dumps(
                                          {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                           'dst': dic['dst']}))


                    else:
                        temp = []
                        maxes = []
                        for p in peer:
                            maxes.append(p['selfOrigin'])
                        if maxes.count(True) > 0:
                            indices = [j for j, y in enumerate(maxes) if y == True]
                            for z in indices:
                                temp.append(peer[z])
                            peer = temp

                        if len(peer) == 1:
                            if not ((self.relations[srcif] == "peer" or self.relations[srcif] == "prov") and (
                                    self.relations[
                                        peer[0]['peer']] == "peer" or self.relations[peer[0]['peer']] == "prov")):
                                self.send(peer[0]['peer'],
                                          json.dumps(
                                              {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                               'dst': dic['dst']}))
                        else:
                            temp = []
                            maxes = []
                            for p in peer:
                                maxes.append(len(p['ASPath']))

                            indices = [j for j, y in enumerate(maxes) if y == min(maxes)]
                            for z in indices:
                                temp.append(peer[z])
                            peer = temp

                            if len(peer) == 1:
                                if not ((self.relations[srcif] == "peer" or self.relations[srcif] == "prov") and (
                                        self.relations[
                                            peer[0]['peer']] == "peer" or self.relations[
                                            peer[0]['peer']] == "prov")):
                                    self.send(peer[0]['peer'],
                                              json.dumps(
                                                  {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                                   'dst': dic['dst']}))
                            else:
                                temp = []
                                maxes = []
                                for p in peer:
                                    maxes.append(p['origin'])

                                if maxes.count('IGP') > 0:
                                    indices = [j for j, y in enumerate(maxes) if y == 'IGP']
                                    for z in indices:
                                        temp.append(peer[z])
                                    peer = temp
                                if len(peer) == 1:
                                    if not ((self.relations[srcif] == "peer" or self.relations[
                                        srcif] == "prov") and (self.relations[
                                                                       peer[0]['peer']] == "peer" or self.relations[
                                                                       peer[0]['peer']] == "prov")):
                                        self.send(peer[0]['peer'],
                                                  json.dumps(
                                                      {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                                       'dst': dic['dst']}))
                                else:
                                    if maxes.count('EGP') > 0:
                                        indices = [j for j, y in enumerate(maxes) if y == 'EGP']
                                        for z in indices:
                                            temp.append(peer[z])
                                        peer = temp
                                    if len(peer) == 1:
                                        if not ((self.relations[srcif] == "peer" or self.relations[
                                            srcif] == "prov") and (self.relations[
                                                                           peer[0]['peer']] == "peer" or self.relations[
                                                                           peer[0]['peer']] == "prov")):
                                            self.send(peer[0]['peer'],
                                                      json.dumps(
                                                          {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                                           'dst': dic['dst']}))
                                    else:
                                        maxes = []
                                        temp = []
                                        for p in peer:
                                            quads = p['peer'].split('.')
                                            maxes.append((int(quads[0]) << 24) + (int(quads[1]) << 16) +
                                                         (int(quads[2]) << 8) + int(quads[3]))

                                        indices = [j for j, y in enumerate(maxes) if y == min(maxes)]
                                        for z in indices:
                                            temp.append(peer[z])
                                        peer = temp
                                        if not (self.relations[srcif] == "peer" or self.relations[
                                            srcif] == "prov" and self.relations[peer[0]['peer']] == "peer" or
                                                self.relations[peer[0]['peer']] == "prov"):
                                            self.send(peer[0]['peer'],
                                                      json.dumps(
                                                          {'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                                           'dst': dic['dst']}))

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor,
                      json.dumps({"type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}}))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))
        print("sent to " + network)

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                self.processMsg(msg, srcif)

        return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
