#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, copy
from difflib import SequenceMatcher


class Router:
    relations = {}
    sockets = {}
    ports = {}
    table = []

    def processMsg(self, msg):
        dic = json.loads(msg)
        print(dic)
        if dic['type'] == "update":
            self.table.append({'network': dic['msg']['network'], 'netmask': dic['msg']['netmask'], 'peer': dic['src'],
                               'localpref': dic['msg']['localpref'], 'ASPath': dic['msg']['ASPath'],
                               'selfOrigin': dic['msg']['selfOrigin'], 'origin': dic['msg']['origin']})
            temp = copy.deepcopy(dic['msg'])
            del temp['localpref']
            del temp['origin']
            del temp['selfOrigin']
            temp['ASPath'].insert(0, self.asn)
            for neighbors in self.relations:
                if dic['src'] != neighbors:
                    self.send(neighbors, json.dumps({'msg': {'netmask': temp['netmask'], 'ASPath': temp['ASPath'],
                                                             'network': temp['network']}, 'src': self.our_addr(neighbors),
                                                     'dst': neighbors, 'type': 'update'}))
        if dic['type'] == "dump":
            for neighbors in self.relations:
                self.send(neighbors, json.dumps({'src': self.our_addr(neighbors), 'dst': neighbors, 'type': 'table',
                                         'msg': self.table}))

        if dic['type'] == "data":
            peer = []
            for net in self.table:
                if dic['dst'][0: dic['dst'].index('.')] in net['network']:
                    peer.append(net)
                    break
            if len(peer) == 0:
                self.send(dic['src'], json.dumps({'src': dic['src'], 'dst': dic['dst'], 'type': 'no route',
                                                  'msg': {}}))
            elif len(peer) == 1:
                self.send(peer[0]['peer'], json.dumps({'type': 'data', 'msg': dic['msg'], 'src': dic['src'],
                                                       'dst': dic['dst']}))

            else:
                temp = []
                maxes = []
                for p in range(len(peer)):
                    maxes.append(SequenceMatcher(None, peer[p]['network'], dic['dst']).ratio())
                if maxes.count(max(maxes)) > 1:
                    indices = [j for j, y in enumerate(maxes) if y == max(maxes)]
                    for z in indices:
                        temp.append(peer[z])
                    peer = temp

                    if len(peer) == 1:
                        self.send(peer[0]['peer'], json.dumps({'type': 'data', 'msg': dic['msg'], 'src': dic['src'], 'dst': dic['dst']}))
                    else:
                        temp = []
                        maxes = []
                        for p in range(len(peer)):
                            maxes.append(p['localpref'])
                        if maxes.count(max(maxes)) > 1:
                            indices = [j for j, y in enumerate(maxes) if y == max(maxes)]
                            for z in indices:
                                temp.append(peer[z])
                            peer = temp

                        if len(peer) == 1:
                            self.send(peer[0]['peer'], json.dumps({'type': 'data', 'msg': dic['msg'], 'src': dic['src'], 'dst': dic['dst']}))
                        else:
                            temp = []
                            maxes = []
                            for p in range(len(peer)):
                                maxes.append(p['selfOrigin'])
                            if maxes.count(True) > 1:
                                indices = [j for j, y in enumerate(maxes) if y == True]
                                for z in indices:
                                    temp.append(peer[z])
                                peer = temp

                                if len(peer) == 1:
                                    self.send(peer[0]['peer'], json.dumps({'type': 'data', 'msg': dic['msg'], 'src': dic['src'], 'dst': dic['dst']}))
                                else:
                                    temp = []
                                    maxes = []
                                    for p in range(len(peer)):
                                        maxes.append(len(p['ASPath']))
                                    if maxes.count(min(maxes)) > 1:
                                        indices = [j for j, y in enumerate(maxes) if y == min(maxes)]
                                        for z in indices:
                                            temp.append(peer[z])
                                        peer = temp

                                        if len(peer) == 1:
                                            self.send(peer[0]['peer'], json.dumps({'type': 'data', 'msg': dic['msg'], 'src': dic['src'], 'dst': dic['dst']}))
                                        else:
                                            temp = []
                                            maxes = []
                                            for p in range(len(peer)):
                                                maxes.append(p['origin'])
                                            if maxes.count('IGP') > 1:
                                                indices = [j for j, y in enumerate(maxes) if y == 'IGP']
                                                for z in indices:
                                                    temp.append(peer[z])
                                                peer = temp
                                            elif maxes.count('IGP') == 0:
                                                if maxes.count('EGP') > 1:
                                                    indices = [j for j, y in enumerate(maxes) if y == 'EGP']
                                                    for z in indices:
                                                        temp.append(peer[z])
                                                    peer = temp
                                                elif maxes.count('EGP') == 0:
                                                    if len(peer) == 1:
                                                        self.send(peer[0]['peer'], json.dumps({'type': 'data', 'msg': dic['msg'], 'src': dic['src'], 'dst': dic['dst']}))
                                                    else:
                                                        for p in peer:
                                                            quads = p['peer'].split('.')
                                                            maxes.append(
                                                                (int(quads[0]) << 24) + (int(quads[1]) << 16) +
                                                                (int(quads[2]) << 8) + int(quads[3]))
                                                        self.send(peer[peer.index(max(peer))]['peer'],
                                                                  json.dumps(dic['msg']))


    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor,
                      json.dumps({"type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}}))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                self.processMsg(msg)

        return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
